간단한 노트

나중에 이걸 바탕으로 글을 작성할 예정

# Closest pair of points.

Brute force $\Theta(n^2)$

한 pair 를 뽑을 때마다, 이전 최소값과 비교해서 바꾸거나 유지 -> O(1)

이게 너무 더럽게 느림 -> 분할정복 아이디어 도입

preprocess : input을 x랑 y로 각각 정렬 (O(nlogn)) 
// 왜 preprocess 는 마지막 시간 계산에 안들어갈까??
// 내 생각에는 어쨌든 간에 메인 알고리즘을 계산하는데에는 영향이 없어서 인 것 같다.

divide : n/2, n/2 로 나눔 (x median을 기준으로)

merge : 합치면서 추가 작업

추가 작업이 핵심

중앙선을 기준으로 왼쪽 오른쪽 각각 $\delta$ 만큼의 영역을 고려

왜 $\delta$? $\delta$보다 작은걸 찾아야 하니까.

그 영역을 y 로 sorting 

이때 이 sorting 은 preprocessing 된 list 를 바탕으로 하면 되기 때문에, O(n)

찾고자 하는건 $\delta$ 보다 작은 pair

간단하게 생각해보면 한 점보다 위에 있는 모든 점들을 비교하면 되나 싶지만, 이거 생각보다 시간이 많이 걸린다.

그래서 어디까지 비교해야 하는지를 정하자!

애초에 이게 왜 가능했을까?

많은 제약들이 명확하게 존재하기 때문.

점들이 위치하는게 가로 $2\delta$의 직사각형이고, 찾는게 $\delta$보다 작은 pair니까.. 뭔가 방법이 있을 것이라고 추론이 가능.

결과적으로는 $|i-j|\geq12$ 가 기준. 
// 이거 내 생각에는 8도 된다.
// 사실 내 생각이라기보다는 여러 자료들이 그렇게 말하고 있는데..
// 교수님은 직사각형을 정사각형으로 자른 다음, 그 안에 포인트가 위치한다는 논리로 들어갔는데
// 만약에 어떤 점을 기준으로 정사각형을 그리기 시작하면 (그러니까 그 점이 가장 낮은 행의 edge에 포함되도록) 7개의 박스만 비교하면 된다.

왜? 

$\delta/2$ 정사각형으로 내부를 잘라보면 (왜 이렇게 잘랐을까? 내 생각에는 이게 제일 편하다. 정말 정확하게 자르려면 $\sqrt(2)$ 막 이렇게 자르면 되는데.. 이건 직사각형을 균등하게 못자르니까.. 어렵다)

각 정사각형에는 무조건 하나의 점만 존재. 왜? 만약 2개 이상이 존재한다면 이는 $\delta$보다 작은 길이의 pair 가 한쪽 (왼 or 오)에 존재한다는 것 => 모순

그리고 최소한 두 점이 2행이 떨어져 있어야 함(2행 = $\delta$)

따라서 11개의 box차가 최대. (그래서 12보다 크거나 같으면 안된다! 라는 거다)

이제 time complexity 를 계산해보면

$T(n)\leq 2T(n/2)+O(n)+O(n)+O(n)=>T(n)=O(nlogn)$

각각은

divide 하는데 O(n)

y로 sort 하는데 O(n)

12개씩 검사하는데 O(n)

여러번 보다보니까 별로 안어려운데.. 솔직히 이걸 처음 생각해낸 사람은 뭐하는 사람일까?

# Matrix Multiplication

매트릭스 곱은 어케 하더라?

한 element 구하는데 $n$, 총 $n^2$번 해야하니까 토탈 $n^3$

개느림. 진짜 많이 느린거임

근데 애초에 이걸 줄일 수가 있을까?

왜냐면 뭔가.. 죄다 독립이잖아.

근데 참.. 똑똑한 사람이 많다.

스트라센 이라는 사람이 이걸 줄이는 방법을 찾아냈다.

$\begin{bmatrix}A & B\\ C & D\end{bmatrix}$

$\begin{bmatrix}E & F\\ G & H\end{bmatrix}$

$\begin{bmatrix}AE+BG & AF+BH\\ CE+DG & CF+DH\end{bmatrix}$

이렇게 되면 $n/2$ subproblem이 8개가 생성되는데..

이거 구해보면 complexity가 그대로다 ㅋㅋ (마스터 정리!)

이걸 정말 놀라운 트릭을 써서 문제 수를 7개로 줄일 수 있다.

이럼 $O(n^(log_27))$ 으로 떨어진다.

교수님이 수업시간에 위키 보여줬는데, 지금은 훨씬 더 떨어진듯 (2015년)

# Polynomial multiplication

이게 좀 어렵더라.

FFT? 라는 아이디어를 사용하던데 당췌 뭔소린짘ㅋㅋㅋ

일단은 기본적인 접근법 까지는 알겠따.

$A(x)=a_0+a_1x+\cdots +a_dx^d$

$B(x)=b_0+b_1x+\cdots +b_dx^d$

두 다항식을 곱하면

$C(x)=c_0+c_1x+\cdots +c_{2d}x^{2d}$

만약에 그냥 하면 얼마지?

대략 $O(d^2)$

왜냐면 $c_k$ 구하는데 k+1 번 곱하고 k 번 더하니까 linear

거기에 k가 0부터 2d 까지 해야하니까 그렇다.

여기서 아이디어!

> A degree d polynomial is uniquely characterized by its values at any d+1 distinct points

이게 왜이럴까... 이건 나중에 책 찾아봐야겠따.

어쨌든 간에 이 아이디어를 적용하면

$x_0$ 부터 $x_d$ 까지 d+1 개의 x 값을 뽑아서 $A(x)$ 에 집어넣으면

$(x_0, A(x_0))$ 처럼 d+1 개의 점을 얻어낼 수 있음.

Evaluation / Interpolation

전자는 coefficient 로부터 점들을, 후자는 반대로.

$C(x_i)=A(x_i)B(x_i)$

4가지 과정

Selection
포인트 뽑기
O(n)

Evaluation
A와 B에 대해서 evaluation
O(nd) 아닌가?
고민좀 해봐야할듯
아 애초에 이걸 따져야 하는구나 ㅋㅋ
이걸 이제 FFT를 이용해서 time complexity 를 구해야 하는군!

Multiplication
Evaluation 에서 구한거 곱하기
O(n)

Interpolation
역방향으로 구하기
(역행렬 쓰면 됨) 
//이거 time complexity 어떻게 되지?? 역행렬 time complexity는 모르겠는뎅..

## Evaluation by FFT

만약에 $\pm x_0, \pm x_1, \cdots, \pm x_{n/2-1}$ 로 놔둔다면..?
//이거 (n-1)/2 아닌가??? 왜 n/2 - 1이지???

이게 왜.. 왜 좋은 아이디어 일까?

신기하게도 $A(x)=A_e(x^2)+xA_o(x^2)$로 분리가 된다.

이걸.. 이걸 잘 생각해보면

T(n) 을 2T(n/2) 로 바꿀 수 있다.

그리고 곱하고 더해서 A를 만들어내는게 총.. n 번 있으니까.. O(n)

근데 문제가 뭐냐.. 

이게 재귀가 안된다.

이게 이해가 안간다.

이 아래로 어떻게 내려간다는거지?????

아.. 이제 애초에 그게 그렇게 해두고 나면 더 내려갈 수가 없지

애초에 다 양수고, 숫자 크기가 같다는 보장도 없으니.

그래서 뭔 희안한 테크닉을 쓰는 것 가은데.. 이건 당다음 시간에 더 들어봐야 하겠다.

아 왠지.. 왠지 리버싱을 하는 이유를 알 것 같다.

이 방향대로 가면 절대 뭘 얻을 수가 없어

리버싱을 해야돼.

