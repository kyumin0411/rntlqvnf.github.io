2주차..
3번 

divide and conquer

# Binary Search

중간 인덱스 값!

반만 선택

탐색 알고리즘

$T(n)=T(n/2)+O(1)$

# Merge Sort

반 잘라서 거기서 소팅하자

$T(n)=2T(n/2)+O(n)$

$O(nlogn)$

우리가 항상 upper bound를 구하긴 하지만, 때에 따라서 lower bound를 구할 수도 있기는 해요.

Merge Sort의 lower bound를 구해보면

(이거 따지고 보면 그냥 머지 소트의 lower bound라기 보다, 좀 일반적인 느낌. comparision base model을 전부 말하는 것 같은데)

leaf의 개수가 n! 개.

depth d의 tree는 최대 $2^d$개의 leaf를 가짐

결국 최소 몇번 탐색해야하는가 도 알 수 있음..?

따라서, $logn!=\Theta (nlogn)$ 

그러니까... 오메가가 애초에 무슨 의미를 가지지?

내가 오해하고 있었네.

최악의 경우에도, 일정 바운드 이상임을 보인거네.

내가 항상 뭔 수식의 lower bound를 구해서 착각했따 ㅎㅎ

# Finding Medians and Selection

가장 간단하게..?

소팅해서 a[k] 반환하는거지.

대충 값 하나 잡아서

3개로 분할

k를 찾고 싶다면, 개수를 비교!

최악의 경우에는 한쪽에 다 쏠리니까

$T(n)=T(n-1)+O(n)$

## Randomized Selection

보다시피 이렇게 분할하는건 드릅게 뽑는거에 의존하거든.

그래서 아예 뽑는 것 자체를 좋은 걸 뽑자! 라는게 아이디어.

좋은걸 뽑는것도 time complexity에 추가해보리면 되자나.

25% 75% 사이에 있는 값을 뽑아야 함

1/2 1/2 확률

최악의 경우

$T(n)<=T(3n/4)+O(c\bullet n)$

여기서 의문. 왜 c 를 곱해야 하지?

독립 아닌가?

아하! 왜냐하면 이건 얘가 그 사이에 있는지 아는데 걸리는 시간인거지

뽑고, 이제 이게 좋은 범위 안에 있는지 확인해야 하니까.

확인을 하게 되면 자연스럽게 나눠지고.

그래서 곱한거임

## Deterministic Selection

요놈이 재밌는데.. 얘는 교재에 없거든?

좋은 v를 위처럼 랜덤하게 아니라, 좀 결정 가능하게 고를수는 없냐

Medians of medians 는 중간값을 정확히 찾지는 않지만 중간값과 근접한 값을 찾아주는 알고리즘 입니다

5개로 짤라. 그러면 n/5 개가 생겨

여기서 각각 median을 골라 (이거는 상수 시간 * n)

n/5개의 median들 중에서 median을 찾아야 해!

그렇게 고른 메디안은 영역을 어떻게 자를까..?

1/2 + 1/2*2/5 = 7/10

최대 영역은 저렇게 되거든.

그럼 저기서 또 하면 돼.

애초에 근데 이게 뭘 찾으려는 거임..?

좋은 v를 결정론 적으로 찾으려는거지?

여기서의 T(n)은 뭘구하는 T(n)인거임?

k번째.

그러니까, 피벗을 골랐다면 이 피벗이 어디에 속하는지 조사.

아까 위에 아이디어랑 동일하지.

그냥 고르는 방법이 좀 달라졌을 뿐임.
